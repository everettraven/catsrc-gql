package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.22

import (
	"catsrc-gql/server/graph/model"
	"context"
)

// Packages is the resolver for the packages field.
func (r *queryResolver) Packages(ctx context.Context, packageName *string) ([]*model.OlmPackage, error) {
	packages := []*model.OlmPackage{}
	for _, pack := range r.catalog.Packages {
		// filter for package name
		if packageName != nil {
			if pack.Name != *packageName {
				continue
			}
		}
		p := &model.OlmPackage{
			Schema:         pack.Schema,
			Name:           pack.Name,
			DefaultChannel: pack.DefaultChannel,
			Description:    &pack.Description,
		}
		if pack.Icon != nil {
			p.Icon = &model.Icon{
				Base64data: string(pack.Icon.Data),
				Mediatype:  pack.Icon.MediaType,
			}
		}
		packages = append(packages, p)
	}

	return packages, nil
}

// Bundles is the resolver for the bundles field.
func (r *queryResolver) Bundles(ctx context.Context, packageName *string, bundleName *string) ([]*model.OlmBundle, error) {
	bundles := []*model.OlmBundle{}

	for _, bundle := range r.catalog.Bundles {
		// filter for bundle name
		if bundleName != nil {
			if bundle.Name != *bundleName {
				continue
			}
		}

		// filter for package name
		if packageName != nil {
			if bundle.Package != *packageName {
				continue
			}
		}

		b := &model.OlmBundle{
			Schema:        bundle.Schema,
			Package:       bundle.Package,
			Name:          bundle.Name,
			Image:         bundle.Image,
			Properties:    []*model.Property{},
			RelatedImages: []*model.RelatedImage{},
		}

		for _, prop := range bundle.Properties {
			p := &model.Property{
				Type:  prop.Type,
				Value: prop.Value,
			}
			b.Properties = append(b.Properties, p)
		}

		for _, relatedImage := range bundle.RelatedImages {
			ri := &model.RelatedImage{
				Image: relatedImage.Image,
				Name:  &relatedImage.Name,
			}
			b.RelatedImages = append(b.RelatedImages, ri)
		}

		bundles = append(bundles, b)
	}

	return bundles, nil
}

// Channels is the resolver for the channels field.
func (r *queryResolver) Channels(ctx context.Context, packageName *string, channelName *string) ([]*model.OlmChannel, error) {
	channels := []*model.OlmChannel{}
	for _, channel := range r.catalog.Channels {
		// filter for channel name
		if channelName != nil {
			if channel.Name != *channelName {
				continue
			}
		}

		// filter for package name
		if packageName != nil {
			if channel.Package != *packageName {
				continue
			}
		}

		c := &model.OlmChannel{
			Schema:  "olm.channel",
			Package: channel.Package,
			Name:    channel.Name,
			Entries: []*model.ChannelEntry{},
		}

		for _, entry := range channel.Entries {
			ce := &model.ChannelEntry{
				Name:      entry.Name,
				Replaces:  &entry.Replaces,
				Skips:     entry.Skips,
				SkipRange: &entry.SkipRange,
			}
			c.Entries = append(c.Entries, ce)
		}

		channels = append(channels, c)
	}
	return channels, nil
}

// Metas is the resolver for the metas field.
func (r *queryResolver) Metas(ctx context.Context, packageName *string, schema *string) ([]*model.OlmMeta, error) {
	metas := []*model.OlmMeta{}
	for _, meta := range r.catalog.Others {
		// filter for schema
		if schema != nil {
			if meta.Schema != *schema {
				continue
			}
		}

		// filter for package name
		if packageName != nil {
			if meta.Package != *packageName {
				continue
			}
		}

		m := &model.OlmMeta{
			Schema:  meta.Schema,
			Package: meta.Package,
			Blob:    meta.Blob,
		}

		metas = append(metas, m)
	}
	return metas, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
